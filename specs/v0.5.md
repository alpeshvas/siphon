# Siphon Spec v0.5

A minimal DSL for extracting data from JSON APIs. Like a siphon draws liquid from a container, Siphon draws the data you need from nested JSON structures.

## Table of Contents

- [Overview](#overview)
- [Installation](#installation)
- [Quick Start](#quick-start)
- [Spec Format](#spec-format)
- [Path Syntax](#path-syntax)
- [Extended Extraction](#extended-extraction)
- [Ancestor Filtering](#ancestor-filtering)
- [API Reference](#api-reference)
- [Behavior Reference](#behavior-reference)
- [Examples](#examples)
- [Changes from v0.4](#changes-from-v04)

---

## Overview

Siphon is ~100 lines of Python with no runtime dependencies. It provides a declarative way to extract data from JSON using a spec-based approach.

**Key features:**
- Simple JSONPath-like extraction: `$.data.id`
- Array iteration with `[*]`
- Filtering with `where` (returns first match by default)
- **Ancestor filtering**: `where` can match properties from any parent level
- Field projection/renaming with `select`
- Collect all matches with `collect: true`

---

## Installation

```bash
pip install siphon-dsl
```

Optional dependencies:
```bash
pip install siphon-dsl[http]   # for fetch_and_process (requires requests)
pip install siphon-dsl[typed]  # for Pydantic-validated specs
```

---

## Quick Start

```python
from siphon import process

data = {
    "data": {
        "id": "prod_123",
        "items": [
            {"id": 1, "status": "active", "name": "Widget"},
            {"id": 2, "status": "inactive", "name": "Gadget"},
            {"id": 3, "status": "active", "name": "Thing"},
        ],
    }
}

spec = {
    "extract": {
        "id": "$.data.id",
        "first_active": {
            "path": "$.data.items[*]",
            "where": {"status": "active"},
        },
        "all_active": {
            "path": "$.data.items[*]",
            "where": {"status": "active"},
            "select": {"item_id": "id", "item_name": "name"},
            "collect": True,
        },
    }
}

result = process(spec, data)
# {
#   "id": "prod_123",
#   "first_active": {"id": 1, "status": "active", "name": "Widget"},
#   "all_active": [
#     {"item_id": 1, "item_name": "Widget"},
#     {"item_id": 3, "item_name": "Thing"}
#   ]
# }
```

---

## Spec Format

A spec is a dictionary with an `extract` key containing field definitions:

```yaml
extract:
  field_name: <extraction_expression>
  another_field: <extraction_expression>
```

Each extraction expression can be:
1. **Simple string path**: `"$.path.to.value"`
2. **Extended object**: `{path, where, select, collect}`

### FieldSpec Schema

```python
@dataclass
class FieldSpec:
    path: str                    # Required: JSONPath expression
    where: dict | None = None    # Optional: filter conditions
    select: dict | None = None   # Optional: field projection/renaming
    collect: bool = False        # Optional: return all matches
```

---

## Path Syntax

Siphon uses JSONPath-like dot notation to traverse JSON structures.

### Simple Paths

Extract nested values using dot notation:

```yaml
extract:
  id: "$.data.id"
  name: "$.data.profile.name"
```

The `$` prefix is optional:
```yaml
extract:
  id: "data.id"       # Same as "$.data.id"
```

### Array Iteration

Use `[*]` to iterate over arrays:

```yaml
extract:
  first_name: "$.data.items[*].name"    # Returns first item's name
```

**Important:** Without `collect: true`, array paths return the **first match only**.

### Multiple Array Levels

Chain multiple `[*]` for deeply nested arrays:

```yaml
extract:
  first_price: "$.categories[*].products[*].variants[*].price"
```

This traverses:
1. Each category
2. Each product in each category
3. Each variant in each product
4. Returns the first `price` found

### Nested Object Access

Access nested properties within array items:

```yaml
extract:
  first_amount: "$.data.items[*].pricing.amount"
```

---

## Extended Extraction

For filtering, projection, or collecting multiple results, use the extended format:

```yaml
field_name:
  path: "$.path.to.array[*]"
  where: {field: "value"}      # optional
  select: {new: "old.path"}    # optional
  collect: true                # optional (default: false)
```

### `where` - Filtering

Filter array items by field values:

```yaml
extract:
  active_item:
    path: "$.data.items[*]"
    where: {status: "active"}
```

**Multiple conditions** use AND logic:
```yaml
extract:
  premium_active:
    path: "$.data.items[*]"
    where:
      status: "active"
      tier: "premium"
```

**Nested field matching** with dot notation:
```yaml
extract:
  expensive:
    path: "$.data.items[*]"
    where: {"pricing.amount": 100}
```

### `select` - Field Projection

Rename and reshape the extracted data:

```yaml
extract:
  item:
    path: "$.data.items[*]"
    select:
      item_id: "id"
      item_name: "name"
      cost: "pricing.amount"
      curr: "pricing.currency"
```

**Input:**
```json
{"id": 1, "name": "Widget", "pricing": {"amount": 100, "currency": "USD"}}
```

**Output:**
```json
{"item_id": 1, "item_name": "Widget", "cost": 100, "curr": "USD"}
```

### `collect` - Return All Matches

By default, extraction returns the **first match**. Set `collect: true` to get all:

```yaml
extract:
  all_names:
    path: "$.data.items[*].name"
    collect: true

  all_active:
    path: "$.data.items[*]"
    where: {status: "active"}
    select: {id: "id", name: "name"}
    collect: true
```

---

## Ancestor Filtering

**New in v0.5**: Filter nested items by properties from parent levels.

When extracting from nested arrays, `where` conditions can match properties from any ancestor level in the path, not just the innermost item.

### How It Works

As Siphon traverses nested arrays, it accumulates properties from each level into a context:

```
$.pricesByDateRange[*].rates[*].passengers[*]
        ↓                 ↓          ↓
   context = {       += {rateId,   += {pricingCategoryId,
     from, to,          title,         title, price, ...}
     rates}             passengers}
```

The `where` filter checks against this merged context.

### Example: Filter by Parent Property

Extract passengers filtered by their parent rate's `rateId`:

```yaml
extract:
  passengers:
    path: "$.pricesByDateRange[*].rates[*].passengers[*]"
    where: {rateId: 1760309}   # rateId is on rate, not passenger!
    select:
      pricingCategoryId: "pricingCategoryId"
      title: "title"
      ticketCategory: "ticketCategory"
      amount: "price.amount"
      currency: "price.currency"
    collect: true
```

**Input:**
```json
{
  "pricesByDateRange": [
    {
      "from": "2026-01-20",
      "to": "2027-01-20",
      "rates": [
        {
          "rateId": 1565415,
          "title": "All Inclusive",
          "passengers": [
            {"pricingCategoryId": 789585, "title": "Adult", "ticketCategory": "ADULT", "price": {"amount": 184.35, "currency": "EUR"}}
          ]
        },
        {
          "rateId": 1760309,
          "title": "Standard Tour",
          "passengers": [
            {"pricingCategoryId": 887614, "title": "Adult", "ticketCategory": "ADULT", "price": {"amount": 67.21, "currency": "EUR"}},
            {"pricingCategoryId": 887615, "title": "Child", "ticketCategory": "CHILD", "price": {"amount": 61.04, "currency": "EUR"}}
          ]
        }
      ]
    }
  ]
}
```

**Output:**
```json
{
  "passengers": [
    {"pricingCategoryId": 887614, "title": "Adult", "ticketCategory": "ADULT", "amount": 67.21, "currency": "EUR"},
    {"pricingCategoryId": 887615, "title": "Child", "ticketCategory": "CHILD", "amount": 61.04, "currency": "EUR"}
  ]
}
```

### Multi-Level Ancestor Filtering

Filter by properties from multiple ancestor levels:

```yaml
extract:
  specific_passengers:
    path: "$.pricesByDateRange[*].rates[*].passengers[*]"
    where:
      from: "2026-01-20"    # from pricesByDateRange level
      rateId: 1760309       # from rates level
    collect: true
```

### Name Conflicts

If the same property name exists at multiple levels, the **innermost value wins**:

```json
{
  "items": [
    {
      "title": "Category Title",
      "products": [
        {"title": "Product Title"}
      ]
    }
  ]
}
```

Filtering `where: {title: "Product Title"}` matches the innermost `title`.

---

## API Reference

### `process(spec, data) -> dict`

Extract data from a dictionary using a spec.

```python
from siphon import process

result = process(spec, data)
```

**Parameters:**
- `spec`: Extraction specification with `extract` key
- `data`: Source JSON data as a dictionary

**Returns:** Dictionary with extracted fields

### `fetch_and_process(spec, base_url) -> dict`

Fetch JSON from an API and extract data.

```python
from siphon import fetch_and_process

spec = {
    "request": {"path": "/api/products"},
    "extract": {
        "products": {"path": "$.data[*].name", "collect": True}
    }
}

result = fetch_and_process(spec, "https://api.example.com")
```

**Parameters:**
- `spec`: Spec with `request.path` and `extract` keys
- `base_url`: API base URL (combined with `request.path`)

**Returns:** Dictionary with extracted fields

**Requires:** `pip install siphon-dsl[http]`

### `process_spec(spec, data) -> dict` (Typed)

Pydantic-validated version of `process`.

```python
from siphon.typed import process_spec, ExtractSpec, FieldSpec

spec = ExtractSpec(
    extract={
        "id": "$.data.id",
        "items": FieldSpec(
            path="$.data.items[*]",
            where={"status": "active"},
            collect=True,
        ),
    }
)

result = process_spec(spec, data)
```

**Requires:** `pip install siphon-dsl[typed]`

---

## Behavior Reference

### Return Values

| Scenario | `collect: false` (default) | `collect: true` |
|----------|---------------------------|-----------------|
| Matches found | First match | List of all matches |
| No matches | `None` | `[]` (empty list) |
| Simple path (no `[*]`) | Value at path | Value at path |

### Path Resolution

| Path | Behavior |
|------|----------|
| `$.data.id` | Direct nested access |
| `data.id` | Same as `$.data.id` |
| `$.items[*].name` | First name from items array |
| `$.a[*].b[*].c` | First `c` from nested iteration |

### Filter Matching

- All `where` conditions must match (AND logic)
- Dot notation supported in condition keys: `{"pricing.amount": 100}`
- Ancestor properties available in nested array paths

### Projection Rules

- `select` only applies when extracting objects (not scalars)
- Dot notation supported in source paths: `{"cost": "pricing.amount"}`
- Missing fields become `None`

---

## Examples

### Basic Extraction

```python
data = {"user": {"id": 123, "name": "Alice", "email": "alice@example.com"}}

spec = {
    "extract": {
        "user_id": "$.user.id",
        "user_name": "$.user.name"
    }
}

result = process(spec, data)
# {"user_id": 123, "user_name": "Alice"}
```

### Array with Filtering and Projection

```python
data = {
    "orders": [
        {"id": 1, "status": "shipped", "total": 99.99},
        {"id": 2, "status": "pending", "total": 149.99},
        {"id": 3, "status": "shipped", "total": 29.99},
    ]
}

spec = {
    "extract": {
        "shipped_orders": {
            "path": "$.orders[*]",
            "where": {"status": "shipped"},
            "select": {"order_id": "id", "amount": "total"},
            "collect": True
        }
    }
}

result = process(spec, data)
# {"shipped_orders": [{"order_id": 1, "amount": 99.99}, {"order_id": 3, "amount": 29.99}]}
```

### Nested Arrays with Ancestor Filtering

```python
data = {
    "departments": [
        {
            "name": "Engineering",
            "teams": [
                {"teamId": "eng-1", "members": [{"name": "Alice"}, {"name": "Bob"}]},
                {"teamId": "eng-2", "members": [{"name": "Carol"}]}
            ]
        },
        {
            "name": "Sales",
            "teams": [
                {"teamId": "sales-1", "members": [{"name": "Dave"}]}
            ]
        }
    ]
}

spec = {
    "extract": {
        "eng1_members": {
            "path": "$.departments[*].teams[*].members[*]",
            "where": {"teamId": "eng-1"},  # teamId is on team, not member
            "select": {"member_name": "name"},
            "collect": True
        }
    }
}

result = process(spec, data)
# {"eng1_members": [{"member_name": "Alice"}, {"member_name": "Bob"}]}
```

### Combining Multiple Extractions

```python
spec = {
    "extract": {
        # Simple path
        "api_version": "$.meta.version",

        # First match (no collect)
        "featured_product": {
            "path": "$.products[*]",
            "where": {"featured": True},
            "select": {"name": "name", "price": "pricing.amount"}
        },

        # All matches (with collect)
        "all_prices": {
            "path": "$.products[*].pricing.amount",
            "collect": True
        },

        # Nested with ancestor filter
        "premium_variants": {
            "path": "$.products[*].variants[*]",
            "where": {"tier": "premium"},  # tier could be on product or variant
            "collect": True
        }
    }
}
```

### YAML Spec File

Siphon specs are data, so they can be stored as YAML:

```yaml
# products.siphon.yaml
version: "0.5"

request:
  path: "/api/v1/products"

extract:
  product_id: "$.data.id"

  active_variants:
    path: "$.data.variants[*]"
    where:
      status: "active"
      inStock: true
    select:
      sku: "sku"
      name: "displayName"
      price: "pricing.retail"
    collect: true
```

```python
import yaml
from siphon import fetch_and_process

with open("products.siphon.yaml") as f:
    spec = yaml.safe_load(f)

result = fetch_and_process(spec, "https://api.store.com")
```

---

## Changes from v0.4

- **Added ancestor filtering**: `where` now checks properties from all parent array levels, not just the innermost item
- This enables filtering deeply nested items by their parent's properties without restructuring the data

### Migration

No breaking changes. Existing v0.4 specs work unchanged. The new ancestor filtering is automatically available when using `where` with nested array paths.