# Siphon Spec v0.5

Added ancestor filtering for nested arrays.

## Features
- Simple JSONPath extraction: `$.data.id`
- Array iteration with `[*]`
- Filtering with `where` (returns first match by default)
- **Ancestor filtering**: `where` can match properties from any parent level
- Field projection/renaming with `select`
- Collect all matches with `collect: true`

## Syntax

### Simple extraction
```yaml
field_name: "$.path.to.field"
```

### Extended extraction
```yaml
field_name:
  path: "$.path.to.array[*]"
  where: {field: "value"}      # optional: filter condition (checks all ancestor levels)
  select: {new: "old.path"}    # optional: project/rename fields
  collect: true                # optional: return all matches (default: false)
```

## Ancestor Filtering

When extracting from nested arrays, `where` conditions can match properties from any ancestor level in the path. This enables filtering deeply nested items by their parent's properties.

### Example: Filter nested items by parent property

```yaml
extract:
  passengers:
    path: "$.pricesByDateRange[*].rates[*].passengers[*]"
    where: {rateId: 1760309}  # rateId is on rate, not passenger
    select:
      pricingCategoryId: "pricingCategoryId"
      title: "title"
      ticketCategory: "ticketCategory"
      amount: "price.amount"
      currency: "price.currency"
    collect: true
```

### Input

```json
{
  "pricesByDateRange": [
    {
      "from": "2026-01-20",
      "to": "2027-01-20",
      "rates": [
        {
          "rateId": 1565415,
          "title": "All Inclusive",
          "passengers": [
            {"pricingCategoryId": 789585, "title": "Adult", "ticketCategory": "ADULT", "price": {"amount": 184.35, "currency": "EUR"}}
          ]
        },
        {
          "rateId": 1760309,
          "title": "Standard Tour",
          "passengers": [
            {"pricingCategoryId": 887614, "title": "Adult", "ticketCategory": "ADULT", "price": {"amount": 67.21, "currency": "EUR"}},
            {"pricingCategoryId": 887615, "title": "Child", "ticketCategory": "CHILD", "price": {"amount": 61.04, "currency": "EUR"}}
          ]
        }
      ]
    }
  ]
}
```

### Output

```json
{
  "passengers": [
    {"pricingCategoryId": 887614, "title": "Adult", "ticketCategory": "ADULT", "amount": 67.21, "currency": "EUR"},
    {"pricingCategoryId": 887615, "title": "Child", "ticketCategory": "CHILD", "amount": 61.04, "currency": "EUR"}
  ]
}
```

### How it works

As Siphon traverses nested arrays, it accumulates properties from each level:

1. At `pricesByDateRange[*]`: context = `{from, to, rates}`
2. At `rates[*]`: context += `{rateId, title, passengers}`
3. At `passengers[*]`: context += `{pricingCategoryId, title, ...}`

The `where` filter checks against this merged context, so `rateId` is available even when extracting passengers.

**Note:** If the same property name exists at multiple levels, the innermost value wins.

## Basic Example

```yaml
version: "0.5"

request:
  path: "/products"

extract:
  id: "$.data.id"

  first_active:
    path: "$.data.items[*]"
    where: {status: "active"}
    select: {item_id: "id", item_name: "name"}

  all_active:
    path: "$.data.items[*]"
    where: {status: "active"}
    select: {item_id: "id", item_name: "name"}
    collect: true
```

## Changes from v0.4
- Added ancestor filtering: `where` now checks properties from all parent array levels, not just the innermost item
